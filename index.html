<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>television.box</title>
    <style>
        /* Глобальный сброс стилей для мобилок */
        * {
            -webkit-tap-highlight-color: transparent; /* Убирает синий клик на Android/iOS */
            outline: none;
            box-sizing: border-box;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000; /* Черный фон для полос по краям */
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation; /* Улучшает реакцию на тач */
        }

        /* Контейнер видео */
        #tv-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* ИСПРАВЛЕНИЕ МАСШТАБА */
        video {
            width: 100%;
            height: 100%;
            /* contain = уместить все видео в экран, сохраняя пропорции. 
               cover = заполнить экран, обрезав края. */
            object-fit: contain; 
            display: none;
        }

        /* Шум (Canvas) */
        canvas#static-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            display: block; 
        }

        /* Экран ошибки */
        #error-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 15;
            background: #000;
            color: #ff3333;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }

        #error-screen h2 { font-size: 24px; margin-bottom: 10px; text-transform: uppercase; }
        #error-screen p { font-size: 14px; opacity: 0.8; }

        /* Интро */
        #intro {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 30;
            font-weight: bold;
            letter-spacing: 4px;
            text-align: center;
            pointer-events: none;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            mix-blend-mode: exclusion;
            width: 100%;
        }

        #click-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
        }
    </style>
</head>
<body>

    <div id="intro">
        <div id="main-text">INITIALIZING...</div>
        <div id="sub-text" style="font-size: 12px; margin-top: 10px; opacity: 0.7;">SCANNING REPO FOLDER</div>
    </div>

    <canvas id="static-canvas"></canvas>

    <div id="error-screen">
        <h2>BAD SIGNAL</h2>
        <p>FILE CORRUPTED OR MISSING</p>
        <p id="error-detail" style="font-size: 10px; margin-top: 20px; opacity: 0.5;"></p>
    </div>

    <div id="tv-container">
        <!-- playsinline важен для iOS, чтобы видео не открывалось в плеере на весь экран само -->
        <video id="tv-video" playsinline webkit-playsinline preload="auto"></video>
    </div>

    <div id="click-layer"></div>

    <script>
        // --- 1. НАСТРОЙКИ ---
        const GITHUB_USER = 'kapustinmisha7-stack'; 
        
        // Судя по скриншоту, твой сайт лежит в корневом репозитории
        // Если вдруг не заработает, верни 'tv-clone' или название папки проекта
        const REPO_NAME = 'super-happiness'; 
        
        const FOLDER_PATH = 'videos'; 
        
        let videos = []; 
        let currentIdx = -1;
        let isNoiseActive = true;
        let audioCtx = null;
        let noiseAnimationId;
        let skipTimeout;
        let appReady = false;

        const videoElement = document.getElementById('tv-video');

        // --- 2. GITHUB API ---
        async function fetchVideoList() {
            const apiUrl = `https://api.github.com/repos/${GITHUB_USER}/${REPO_NAME}/contents/${FOLDER_PATH}`;
            
            console.log("Fetching from:", apiUrl);

            try {
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error(`GitHub Error: ${response.status}`);
                
                const data = await response.json();
                
                videos = data
                    .filter(file => file.name.match(/\.(mp4|webm|mov|m4v)$/i))
                    .map(file => file.download_url);

                if (videos.length === 0) throw new Error("No videos found");

                console.log(`Loaded ${videos.length} videos`);
                document.getElementById('main-text').innerText = "television.box";
                document.getElementById('sub-text').innerText = "TAP TO START";
                appReady = true;

            } catch (error) {
                console.error(error);
                document.getElementById('main-text').innerText = "SYSTEM FAILURE";
                document.getElementById('sub-text').innerText = "CHECK CONSOLE";
                document.getElementById('error-detail').innerText = error.message;
                document.getElementById('error-screen').style.display = 'flex';
            }
        }
        
        fetchVideoList();

        // --- 3. АУДИО ---
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playStaticSound(duration = 0.5) {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noiseSource = audioCtx.createBufferSource();
            noiseSource.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 800; 
            const gainNode = audioCtx.createGain();
            gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            noiseSource.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            noiseSource.start();
        }

        // --- 4. ГРАФИКА ---
        const canvas = document.getElementById('static-canvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            // Для лучшей производительности на мобилках уменьшаем разрешение канваса
            canvas.width = window.innerWidth / 2;
            canvas.height = window.innerHeight / 2;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        function startVisualNoise() {
            canvas.style.display = 'block';
            isNoiseActive = true;
            const w = canvas.width;
            const h = canvas.height;
            const idata = ctx.createImageData(w, h);
            const buffer32 = new Uint32Array(idata.data.buffer);
            const len = buffer32.length;
            function loop() {
                if (!isNoiseActive) return;
                for (let i = 0; i < len; i++) {
                    buffer32[i] = (Math.random() < 0.5) ? 0xff000000 : 0xffffffff;
                }
                ctx.putImageData(idata, 0, 0);
                noiseAnimationId = requestAnimationFrame(loop);
            }
            loop();
        }
        startVisualNoise();

        function stopVisualNoise() {
            isNoiseActive = false;
            cancelAnimationFrame(noiseAnimationId);
            canvas.style.display = 'none';
            document.getElementById('error-screen').style.display = 'none';
        }

        // --- 5. ВИДЕО ЛОГИКА ---
        videoElement.addEventListener('playing', () => {
            stopVisualNoise();
            videoElement.style.display = 'block';
            clearTimeout(skipTimeout);
        });

        videoElement.addEventListener('ended', switchChannel);

        videoElement.addEventListener('error', () => {
            console.log("Video Error:", videoElement.error);
            handleError("FILE_LOAD_ERROR");
        });

        function handleError(code) {
            if(!isNoiseActive) startVisualNoise();
            videoElement.style.display = 'none';
            
            const errorScreen = document.getElementById('error-screen');
            document.getElementById('error-detail').innerText = code;
            errorScreen.style.display = 'flex';
            
            playStaticSound(0.2);

            if (skipTimeout) clearTimeout(skipTimeout);
            skipTimeout = setTimeout(switchChannel, 1500);
        }

        function switchChannel() {
            if (!appReady) return; 

            initAudio();
            document.getElementById('intro').style.display = 'none';
            
            startVisualNoise();
            videoElement.style.display = 'none';
            playStaticSound(0.35);

            let newIdx;
            if (videos.length > 1) {
                do {
                    newIdx = Math.floor(Math.random() * videos.length);
                } while (newIdx === currentIdx);
            } else {
                newIdx = 0;
            }
            currentIdx = newIdx;
            
            // Важный хак для мобилок: сначала сброс src, потом загрузка
            videoElement.pause();
            videoElement.src = videos[currentIdx];
            videoElement.load(); 
            
            const playPromise = videoElement.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.warn("Playback prevented:", error);
                    // Обычно это случается, если юзер еще не кликнул.
                    // Но у нас запуск идет через клик, так что должно работать.
                });
            }
        }

        document.getElementById('click-layer').addEventListener('click', (e) => {
            e.preventDefault(); // Предотвращает стандартные зумы и выделения
            
            if (!appReady) return;
            
            if (videoElement.paused && videoElement.src) {
                videoElement.play().catch(() => switchChannel());
            } else {
                switchChannel();
            }
        });

        // Блокировка двойного тапа (зума)
        document.addEventListener('dblclick', function(event) {
            event.preventDefault();
        }, { passive: false });

    </script>
</body>
</html>
